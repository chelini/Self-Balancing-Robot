function [u_l,u_r] = ilqr_fun(state)
%ILQR Summary of this function goes here
%   Detailed explanation goes here
num_iter_opt = 20;
horizon = 20;
u_l = zeros(1,horizon)
u_r = zeros(1,horizon)

state_vec = zeros(4,horizon)
state_vec(:,1) = state(3:end)';

Q = eye(4);
R = eye(2);
P_vec = zeros(4,4*(horizon+1))
P_vec(:,4*(horizon+1)) = Q;
B_vec = [];
for iter = 1:num_iter_opt
    
    %backward
    for step = 1:horizon
       %lineariza
       state_actual = state_vec(:,horizon)
       [A_step,B_step] = linearization_fun(u_l,u_r,state_actual(1),state_actual(2),state_actual(3),state_actual(4));
       B_vec = [B_vec,B_step];
       %calculate P_step
       P_next = P_vec(:,horizon*4 - 3:horizon*4);
       P_step = Q + A_step'*(P_next - P_next*B_step*pinv(R + B_step'*P_next*B_step)*B_step'*P_next)*A_step;
       P_vec = [P_vec,P_step];
    end
    
    %forward
    for step = 1:horizon
       %calculate input
       u_update = pinv(R)*B_vec(:,step*2-1:step*2)'*P_vec(:,step*4 - 3:step*4)*state_vec(:,step);
       u_l(step) = u_l(step) - u_update(1);
       u_r(step) = u_r(step) - u_update(2);
       %forward dynamic
       [theta_ddot,phi_ddot,x_ddot] = forward_dynamic_fun(u_l(step),u_r(step),state_vec(:,step)); 
       %integration
       state_vec(:,step+1) = euler_integration_fun(theta_ddot,phi_ddot,x_ddot,state_vec(:,step),dt);
       

    end
    
end

u_l = 0;
u_r = 0;
end

